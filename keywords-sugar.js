// Generated by SugarLisp v0.5
var sl = require('sugarlisp-core/types');
var match = require('sugarlisp-match/pattern-match');
exports["."] = function(forms) {
  this.transpileSubExpressions(forms);

  return match(forms, function(when) {
    when([
        function(sym) {
          return sym.value === ".";
        },
        match.var("object", match.any),
        match.var("property", match.any)
      ],
      function(vars) {
        return (function(object, property) {
          return sl.transpiled([
            object, ".", property
          ]);
        }).call(this, vars["object"], vars["property"]);
      }, this);
    when([
        match.var("any", match.sldefault)
      ],
      function(vars) {
        return (function(any) {
          return this.error('The dot (.) requires an object and a property');
        }).call(this, vars["any"]);
      }, this);
  }, this);
};
exports["dotprop"] = function(forms) {
  this.transpileSubExpressions(forms);

  return match(forms, function(when) {
    when([
        function(sym) {
          return sym.value === "dotprop";
        },
        match.var("property", match.any),
        match.var("object", match.any)
      ],
      function(vars) {
        return (function(property, object) {
          return sl.transpiled([
            object, ".", property
          ]);
        }).call(this, vars["property"], vars["object"]);
      }, this);
    when([
        match.var("any", match.sldefault)
      ],
      function(vars) {
        return (function(any) {
          return this.error('A dot property (.propname) requires an object');
        }).call(this, vars["any"]);
      }, this);
  }, this);
};
exports["if"] = function(forms) {
  this.transpileSubExpressions(forms);

  return match(forms, function(when) {
    when([
        function(sym) {
          return sym.value === "if";
        },
        match.var("condition", match.any),
        match.var("iftrue", match.any),
        match.var("iffalse", match.any)
      ],
      function(vars) {
        return (function(condition, iftrue, iffalse) {
          return sl.transpiled([
            "(", condition, " ?\n",
            "    ", iftrue, " :\n",
            "    ", iffalse, ")"
          ]);
        }).call(this, vars["condition"], vars["iftrue"], vars["iffalse"]);
      }, this);
    when([
        function(sym) {
          return sym.value === "if";
        },
        match.var("condition", match.any),
        match.var("iftrue", match.any)
      ],
      function(vars) {
        return (function(condition, iftrue) {
          return sl.transpiled([
            "(", condition, " ?\n",
            "    ", iftrue, " : undefined )"
          ]);
        }).call(this, vars["condition"], vars["iftrue"]);
      }, this);
    when([
        match.var("any", match.sldefault)
      ],
      function(vars) {
        return (function(any) {
          return this.error('if expects a condition followed by one (for "then") or two (for "else") body expressions');
        }).call(this, vars["any"]);
      }, this);
  }, this);
};

exports["new"] = function() {
  var args = Array.prototype.slice.call(arguments);
  return match(args, function(when) {
    when([
        function(sym) {
          return sym.value === "new";
        },
        match.var("classname", match.slsymbol)
      ],
      function(vars) {
        return (function(classname, constructorArgs) {
          return (function() {
            this.x(constructorArgs);
            return sl.transpiled([
              "new ", classname, "(", constructorArgs, ")"
            ]);
          }).call(this);
        }).call(this, vars["classname"], vars["_rest"]);
      }, this);
    when([
        function(sym) {
          return sym.value === "new";
        }
      ],
      function(vars) {
        return (function(newArgs) {
          return (function() {
            this.x(newArgs);
            return sl.transpiled([
              "new ", newArgs
            ]);
          }).call(this);
        }).call(this, vars["_rest"]);
      }, this);
    when([
        match.var("any", match.sldefault)
      ],
      function(vars) {
        return (function(any) {
          return this.error("missing class name for new operator?");
        }).call(this, vars["any"]);
      }, this);
  }, this)
};
exports["while"] = function() {
  var args = Array.prototype.slice.call(arguments);
  return match(args, function(when) {
    when([
        function(sym) {
          return sym.value === "while";
        },
        match.var("condition", match.any),
        match.var("body", match.sllist)
      ],
      function(vars) {
        return (function(condition, body) {
          return (function() {
            return sl.transpiled([
              "while(", this.x(condition), ") {\n",
              "    ", this.x(body), "\n",
              "}"
            ]);
          }).call(this);
        }).call(this, vars["condition"], vars["body"]);
      }, this);
    when([
        match.var("any", match.sldefault)
      ],
      function(vars) {
        return (function(any) {
          return this.error("a while loop expects a condition and loop body");
        }).call(this, vars["any"]);
      }, this);
  }, this)
};

exports["times"] = function() {
  var args = Array.prototype.slice.call(arguments);
  return match(args, function(when) {
    when([
        function(sym) {
          return sym.value === "times";
        },
        match.var("varname", match.slsymbol),
        match.var("iterations", match.any),
        match.var("body", match.sllist)
      ],
      function(vars) {
        return (function(varname, iterations, body) {
          return (function() {
            return sl.transpiled([
              "for(var ", varname, " = 0; ", varname, " < ", this.x(iterations), "; ", varname, "++) {\n",
              "    ", this.x(body), "\n",
              "}"
            ]);
          }).call(this);
        }).call(this, vars["varname"], vars["iterations"], vars["body"]);
      }, this);
    when([
        match.var("any", match.sldefault)
      ],
      function(vars) {
        return (function(any) {
          return this.error("a times loop expects a variable name, number of iterations, and the loop body");
        }).call(this, vars["any"]);
      }, this);
  }, this)
};