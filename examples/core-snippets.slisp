;; Some example SugarLisp core dialect code snippets

(console.log (str "Hello" " World"))

;; a simple anonymous function
(var square (function (n)
  (* n n)))
(console.log (square 10))

;; a simple named function
(function myadd (x, y)
  (+ x y))

(try
  (console.log "In try")
  (throw "In catch")
  (function (err)
    (console.log err)))

(if (undefined? window)
  (console.log "Not Running on browser")
  (console.log "Running on browser"))

(if (!== 1 2)
  (console.log "Nos are not equal"))

(if (object? console)
  (console.log "console is an object")
  (console.log "console is not an object"))

;; arrays
(var arr (array 1 2 3 4 5))
(console.log (get 2 arr))

;; empty array
(var mtarr (array))
(console.log "empty array is empty:" (empty? mtarr))

(if (array? console)
  (console.log "console is an array")
  (console.log "console is not an array"))

;; The example below shows the dangers of using a macro
(macro square (x)
  (* ~x ~x))

(console.log (square 10))

;; The code above works fine. Now consider the code below
(var i 2)
(console.log (square ++i))

;; Oops you got 12! An embarrassing square of a no. Thats because the macro
;; expanded to (* ++i ++i) which is multiplying 3 and 4!

(macro mylet (args vals ...rest)
  ((function ~args ~rest) ~@vals))

(mylet (name email tel) ("John" "john@example.com" "555-555-5556")
  (console.log name) (console.log email))

(do
  (console.log "do first expr")
  (console.log "do second expr"))

;; {} is also an alias for "do"
{
  (console.log "curly do first expr")
  (console.log "curly do second expr")
}

;; regular expression
(var re (regex "[a-zA-Z0-9]"))

;; object literals
(var obj (object
  first "fred"
  last "flintstone"
  friends (array "barney" "betty")
  toString (function () (str this.first " " this.last))))

(console.log (obj.toString))

;; simple javascript passthru as a string
(js "console.log('hello from js string');")

;; test the new keyword
(var todayDate (new Date))
(console.log (new Date "October 13, 1975 11:13:00"))

(var dayNum (.getDay todayDate))
(console.log dayNum)

// a traditional javascript switch statement
(var dayName)
(switch dayNum
  0 { (= dayName "sun") (break) }
  1 { (= dayName "mon") (break) }
  2 { (= dayName "tues") (break) }
  3 { (= dayName "wed") (break) }
  4 { (= dayName "thu") (break) }
  5 { (dayName "fri") (break) }
  default { (= dayName "sat") (break) })
(console.log "switch says today is ${dayName}")

;; a simple case
(var dayName (case dayNum
  0 "sun"
  1 "mon"
  2 "tues"
  3 "wed"
  4 "thu"
  5 "fri"
  6 "sat"))
(console.log "case says today is ${dayName}")

;; a simple cond
(var dayMsg (cond
  (=== dayNum 5) "tgif!!"
  (|| (=== dayNum 0) (=== dayNum 6)) "yahoo it's the weekend!"
  true "blech gotta work today it's a weekday"))
(console.log "cond says about today: ${dayMsg}")

;; a simple while loop
;; note the while body is whatever expressions follow the condition
(console.log 'a while loop (5 downto 1)');
(var wx 5)
(while (!= wx 0)
  (console.log wx)
  wx--)

;; a simple times loop
(console.log 'a 4 "dotimes" loop (0 to 3)');
(dotimes (tx, 4)
  (console.log tx))

(console.log "an each loop (1 to 3)")
(each [1, 2, 3] (function (elem i list) (console.log elem)))

;; a list comprehension
(console.log "a list comprehension of ['a','b','c'] with [3,4,5]")
(console.log (list-of
  (letters ['a', 'b', 'c']
   numbers [3, 4, 5])
  [letters, numbers]))

/**
* Examples of more javascript-like syntax sugar
*/

// arrays
(var arr [1 2 3])
(console.log "first is:" (first arr))
(console.log "rest is:" (rest arr))

// with commas (treated same as white space)
(var arrComma [1, 2, 3])

// empty array
(var mtarr2 [])
(console.log "empty array is empty:" (empty? mtarr2))

;; regular expression (and lispy comments are still supported btw)
(var re #/[a-zA-Z0-9]/)
;; and make sure plain / still works right
(var fn (function (x y) (/ x y)))

// js/json style object literals
(var obj {
  first: "fred"
  last: "flintstone"
  friends: ["barney","betty"]
  toString: (function () (str this.first " " this.last))
})

// with commas
(var objComma {
  first: "fred",
  last: "flintstone",
  friends: ["barney","betty"],
  toString: (function () (str this.first " " this.last))
})

(console.log ((objComma.toString)))

// simple javascript passthru as a string
(js "console.log('hello');")

// javscript passthru using a template string
// had trouble with this - the below was a workaround
(var name "fred")
(var greeting 'hello ${name}')
(js "console.log(greeting);")

// test use of "@" for "this"
(var objAt {
  first: "fred",
  last: "flintstone",
  toString: (function() "${@first} ${@last}"),
  dump: (function() (console.log (@toString)))
})

((objAt.dump))

// slashy regexes deserve extra care...
// (cause they can get mixed up with comments and divide!)

// RIGHT NOW A REGEX LIKE /flint/g MISSES THE "g" ON THE END - NEED TO FIX
(console.log "fred flintstone contains 'flint':" (.test #/flint/ "fred flintstone"))
(console.log "fred flintstone contains 'flint':" (#/flint/.test "fred flintstone"))

// here's a line comment before some code
(console.log (/ 10 5))

/* and another block comment this time on one line */
(if (.test #/[^\.]+\.[^\.]+/ "filename.ext")
  (console.log "regex correctly says 'filename.ext' has an extension")
  (console.log "regex incorrectly says 'filename.ext' has no extension"))

// Test of arrow functions

(var arr [1,2,3,4])

(arr.forEach (el) => (console.log el))

// testing lexical this
(function Ubertest (x) {
  (set this.x x)

  (function Test (x) {
    (set this.x x)

    (var arr [1,2,3])
    (arr.forEach (el) => (console.log this.x el))
  })

  (var arr ['a','b','c'])
  (arr.forEach (el) => (new Test "${this.x} ${el}"))
})

(new Ubertest "Uber")
